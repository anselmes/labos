#!/bin/bash
# SPDX-License-Identifier: GPL-3.0

set -eo pipefail

[[ ${DEBUG} -eq 1 ]] && set -x

: "${ARCH:="$(uname -m)"}"
: "${DIR:="$(dirname "$(realpath "$(dirname "$0")")")"}"
: "${LIBVIRT_DIR:="/var/lib/libvirt"}"
: "${IMG_DIR:="${LIBVIRT_DIR}/images"}"
: "${IMG_FILE:="${IMG_DIR}/noble.img"}"

[[ "aarch64" == "${ARCH}" ]] && ARCH="arm64"
[[ "x86_64" == "${ARCH}" ]] && ARCH="amd64"

# todo: load from vault
load_from_vault() {
  echo "loading from vault"
}

# todo: save to vault
save_to_vault() {
  echo "saving to vault"
}

generate_netplan() {
  MACADDR="${1}"
  [[ -z "${MACADDR}" ]] && echo "mac address is required" && exit 1
  yq ".network.ethernets.oam.match.macaddress = \"${MACADDR}\"" "${DIR}/config/netplan/default.yaml"
}

generate_iso_image() {
  ISOCMD="genisoimage"
  if [[ -z $(command -v ${ISOCMD}) ]]; then
    ISOCMD="mkisofs"
    if [[ -z $(command -v ${ISOCMD}) ]]; then
      echo "genisoimage nor mkisofs found"
      exit 1
    fi
  fi

  ${ISOCMD} -joliet -rock -output "${1}" -volid cidata "${@:2}"
}

create_vol() {
  NAME="${1}"
  IMG_FILE="${2}"
  [[ -z "${NAME}" ]] && echo "name is required" && exit 1
  [[ -z "${IMG_FILE}" ]] && echo "image file is required" && exit 1

  VOL="${IMG_DIR}/${NAME}.img"
  if ! grep -qa "${VOL}" <(sudo ls "${VOL}"); then
    sudo qemu-img create -b "${IMG_FILE}" -f qcow2 -F qcow2 "${VOL}" "${3:-16G}"
    qemu-img info "${VOL}"
  fi
}

create_vm() {
  NAME="${1}"
  OS="${2}"
  CPU="${3}"
  MEM="${4}"
  METADATA_FILE="${5}"
  USERDATA_FILE="${6}"
  NETWORK_CONFIG="${7}"
  IMG_FILE="${8}"

  [[ -z "${NAME}" ]] && echo "name is required" && exit 1
  [[ -z "${OS}" ]] && echo "os is required" && exit 1
  [[ -z "${CPU}" ]] && echo "cpu not provided"
  [[ -z "${MEM}" ]] && echo "memory is required" && exit
  [[ -z "${METADATA_FILE}" ]] && echo "metadata file is required" && exit 1
  [[ -z "${USERDATA_FILE}" ]] && echo "userdata file is required" && exit 1
  [[ -z "${NETWORK_CONFIG}" ]] && echo "network config is required" && exit 1
  [[ -z "${IMG_FILE}" ]] && echo "image file is required" && exit

  stat -d "${IMG_DIR}" > /dev/null 2>&1 || sudo mkdir -p "${IMG_DIR}"
  stat -d "${LIBVIRT_DIR}/boot" > /dev/null 2>&1 || sudo mkdir -p "${LIBVIRT_DIR}/boot"

  create_vol "${NAME}" "${IMG_FILE}"
  generate_iso_image "/tmp/${NAME}-cloudinit.iso" "${METADATA_FILE}" "${USERDATA_FILE}" "${NETWORK_CONFIG}"
  sudo mv "/tmp/${NAME}-cloudinit.iso" "${LIBVIRT_DIR}/boot/"

  grep -q "${NAME}" <(sudo virsh list --all) || sudo virt-install \
    --name "${NAME}" \
    --arch "${ARCH}" \
    --os-variant "${OS}" \
    --metadata name="${NAME}",uuid="$(uuidgen)" \
    --boot menu=on \
    --cpu "${CPU}" \
    --memory "${MEM}" \
    --memballoon model=virtio \
    --rng /dev/urandom \
    --tpm model=tpm-tis,version=2.0 \
    --watchdog i6300esb,action=reset \
    --channel unix,target_type=virtio,name=org.qemu.guest_agent.0 \
    --channel unix,target_type=virtio,name=org.libguestfs.channel.0 \
    --disk path="${VOL}",serial="$(uuidgen)" \
    --disk "${LIBVIRT_DIR}/boot/${NAME}-cloudinit.iso",device=cdrom \
    --network none \
    --qemu-commandline="-accel hvf" \
    --graphics none \
    --import \
    --noautoconsole "${@:9}"
}

delete_vm() {
  NAME="${1}"
  [[ -z "${NAME}" ]] && echo "name is required" && exit 1
  if grep -q "${NAME}" <(sudo virsh list --all); then
    sudo virsh destroy "${NAME}"
    sudo virsh dumpxml "${NAME}" | yq -p xml '.domain.os.nvram.+content' | xargs sudo rm -f -
    sudo virsh undefine --remove-all-storage "${NAME}"
  fi
}

print_help() {
  echo """
Commands:
  init        Generate site configs
  bootstrap   Create & configure VMs
  apply       Create & deploy site
  cleanup     Run cleanup tasks

Other Commands:
  version   Show version information

Usage:
  ${0} [flags] [options]

Use \"${0} options\" for a list of global options (applies to all commands).
  """
}

print_options() {
  echo """
The following option can be passed to any command:

  --name <name>             Site name
  --ssh-pubkey <file>       SSH public key file
  --user-data <file>        cloud-init user data file
  --vault <vault>           vault type (icloud | vault)

The following options can be passed to the \"init\" command:

  --load                    Load from vault
  --save                    Save to vault

The following options can be passed to the \"bootstrap\" command:

  --gw                      Bootstrap gateway & nameserver
  --harbor                  Bootstrap harbor

The following options can be passed to the \"cleanup\" command:

  --all                     Cleanup all resources
  --harbor                  Cleanup harbor resources

Examples:
  ${0} bootstrap --gw
  ${0} cleanup --all
  """
}

while [[ $# -gt 0 ]]; do
  case "${1}" in
    -h|--help|help)
      print_help
      exit 0
      ;;
    --name)
      [[ -z "${2}" ]] && echo "name is required" && exit 1
      export SITE_NAME="${2}"
      shift 2
      ;;
    --ssh-pubkey)
      [[ -z "${2}" ]] && echo "ssh pubkey file is required" && exit 1
      export SSH_PUBKEY_FILE="${2}"
      shift 2
      ;;
    --user-data)
      [[ -z "${2}" ]] && echo "userdata file is required" && exit 1
      export USERDATA_FILE="${2}"
      shift 2
      ;;
    --vault)
      [[ -z "${2}" ]] && echo "vault is required" && exit 1
      [[ "${2}" != "icloud" && "${2}" != "vault" ]] && echo "invalid vault" && exit 1
      export VAULT="${2}"
      shift 2
      ;;
    *)
      CMD="${1}"
      ARGS+=${*:2}
      [[ -z "${SITE_NAME}" ]] && export SITE_NAME="skiff"
      SITE_DIR="${DIR}/build/site/${SITE_NAME}"
      [[ -z "${SSH_PUBKEY_FILE}" ]] && export SSH_PUBKEY_FILE="${SITE_DIR}/id_ed25519.pub"
      [[ -z "${USERDATA_FILE}" ]] && export USERDATA_FILE="${SITE_DIR}/user-data"
      [[ -z "${VAULT}" ]] && export VAULT="icloud"
      export SSH_KEY_FILE="$(echo ${SSH_PUBKEY_FILE} | cut -d '.' -f 1)"
      export GNUPGHOME="${SITE_DIR}/.gnupg"
      break
      ;;
  esac
done

if [[ "${ARGS}" == *"--help"* || "${ARGS}" == "-h" ]]; then
  print_help
  exit 0
fi

case "${CMD}" in
  init)
    case "${ARGS}" in
      --load)
        export LOAD_FROM_VAULT=true
        ;;
      --save)
        export SAVE_TO_VAULT=true
        ;;
      *)
        if [[ -n "${ARGS}" ]]; then
          echo "invalid arguments"
          print_options
          exit 1
        fi
        ;;
    esac

    stat "${SITE_DIR}"> /dev/null 2>&1 || mkdir -p "${SITE_DIR}"

    if [[ ${LOAD_FROM_VAULT} == true ]]; then
      load_from_vault
    else
      # ssh config
      stat "${SSH_KEY_FILE}" > /dev/null 2>&1 || ssh-keygen -N "" -C "${SITE_NAME}" -t ed25519 -f "${SSH_KEY_FILE}"

      # gpg config
      if ! gpg --homedir "${GNUPGHOME}" -k "${SITE_NAME}" > /dev/null 2>&1; then
        cat <<eof > "${GNUPGHOME}/${SITE_NAME}.batch"
%no-protection
# %no-ask-passphrase
Key-Type: RSA
Key-Length: 4096
Subkey-Type: 1
Subkey-Length: 4096
Expire-Date: 0
Name-Real: "${SITE_NAME}"
eof
        gpg --no-tty --batch --homedir "${GNUPGHOME}" --gen-key "${GNUPGHOME}/${SITE_NAME}.batch"
      fi
      # PGP="$(gpg --homedir "${GNUPGHOME}" --list-keys "${SITE_NAME}" | head -n +2 | tail -n 1 | tr -d ' ')"
      # echo "${PGP}"

      # pki config
      CA_KEY_FILE="${SITE_DIR}/ca.key"
      CA_FILE="${SITE_DIR}/ca.crt"
      stat "${CA_KEY_FILE}" > /dev/null 2>&1 || openssl genrsa -out "${CA_KEY_FILE}" 4096
      if ! stat "${CA_FILE}" > /dev/null 2>&1; then
        openssl req -new -key "${CA_KEY_FILE}" -out "${SITE_DIR}/ca.csr" -subj "/CN=${SITE_NAME}"
        openssl x509 -req -days 365 -in "${SITE_DIR}/ca.csr" -signkey "${CA_KEY_FILE}" -out "${CA_FILE}"
        openssl pkcs12 -export -out "${SITE_DIR}/ca.pfx" -inkey "${CA_KEY_FILE}" -in "${CA_FILE}" -passout pass:
      fi
    fi

    [[ ${SAVE_TO_VAULT} == true ]] && save_to_vault

    # generate cloud init
    # export ADMISSION="$(sed '/#/d' ${DIR}/config/cloudinit/admission.yaml)"
    export NETPLAN="$(sed '/#/d' ${DIR}/config/netplan/default.yaml)"
    export PKG="$(sed '/#/d' ${DIR}/config/cloudinit/packages.yaml)"
    export PUBKEY="${SSH_PUBKEY_FILE}"
    export CA="${SITE_DIR}/ca.crt"
    export UUID="$(uuidgen)"
    yq '
      . *+ env(NETPLAN) |
      .network.ethernets.oam.match.macaddress = "de:ad:be:ef:00:01"
    ' "${DIR}/config/netplan/default.yaml" > "${SITE_DIR}/network-config"
    yq '
      # . *+ env(ADMISSION) |
      . *+ env(PKG) |
      .ssh_authorized_keys = [load(env(PUBKEY))] |
      .ca_certs.trusted = [load(strenv(CA))]
    ' "${DIR}/config/cloudinit/default.yaml" > "${USERDATA_FILE}"
    yq '
      .instance-id = env(UUID) |
      .local-hostname = env(UUID)
    ' "${DIR}/config/cloudinit/metadata.yaml" > "${SITE_DIR}/meta-data"

    # generate k0s config
    export CNI="${DIR}/config/bootstrap/charts/cni.yaml"
    export CSI="${DIR}/config/bootstrap/charts/csi.yaml"
    export CAPI="${DIR}/config/bootstrap/charts/capi.yaml"
    export SANS="kubernetes.${SITE_NAME}.labos.local"
    export K0S_CONFIG="$(yq '
      . *+ load(env(CNI)) |
      . *+ load(env(CSI)) |
      . *+ load(env(CAPI))
    ' ${DIR}/config/bootstrap/config.yaml)"

    # generate k0sctl config
    yq '
      .spec.hosts[].ssh.keyPath = env(SSH_KEY_FILE) |
      .spec.k0s.config = env(K0S_CONFIG)
    ' "${DIR}/config/bootstrap/cluster.yaml" > "${SITE_DIR}/bootstrap.yaml"

    # fixme: configure route & dns
    export VYOS_CONFIG="${SITE_DIR}/vyos/config.boot.default"
    mkdir -p "${SITE_DIR}/vyos"
    touch "${SITE_DIR}/vyos/meta-data"
    cp -f "${DIR}/config/vyos/network.yaml" "${SITE_DIR}/vyos/network-config"
    cp -f "${DIR}/config/vyos/config.boot.default" "${VYOS_CONFIG}"
    yq '
      .write_files[0].content = load(strenv(VYOS_CONFIG))
    ' "${DIR}/config/vyos/config.yaml" > "${SITE_DIR}/vyos/user-data"
    ;;
  bootstrap)
    case "${ARGS}" in
      --gw)
        export BOOTSTRAP_GW=true
        ;;
      --harbor)
        export BOOTSTRAP_HARBOR=true
        ;;
      *)
        if [[ -n "${ARGS}" ]]; then
          echo "invalid arguments"
          print_options
          exit 1
        fi
        ;;
    esac

    # todo: check initialized

    # create gateway & nameserver
    if [[ ${BOOTSTRAP_GW} == true ]]; then
      NAME="${SITE_NAME}-gw"
      OS="debian10"
      CPU=""
      MEM=4196
      IMG_FILE="${IMG_DIR}/vyos.img"
      ARCH="x86_64" create_vm \
        "${NAME}" \
        "${OS}" \
        "${CPU}" \
        "${MEM}" \
        "${SITE_DIR}/vyos/meta-data" \
        "${SITE_DIR}/vyos/user-data" \
        "${SITE_DIR}/vyos/network-config" \
        "${IMG_FILE}" \
        --qemu-commandline="-netdev vmnet-bridged,id=bridgednet1,ifname=${BRIDGE_IF}" \
        --qemu-commandline="-device virtio-net-pci,id=net2,netdev=bridgednet1,addr=0x3,mac=de:ad:be:ef:00:00" \
        --qemu-commandline="-netdev vmnet-shared,id=sharednet1" \
        --qemu-commandline="-device virtio-net-pci,id=net1,netdev=sharednet1,addr=0x4,mac=de:ad:be:ef:00:01"
    fi

    # create harbor vm
    if [[ ${BOOTSTRAP_HARBOR} == true ]]; then
      NAME="${SITE_NAME}-harbor"
      OS="ubuntu20.04"
      CPU=""
      MEM=8192
      create_vm \
        "${NAME}" \
        "${OS}" \
        "${CPU}" \
        "${MEM}" \
        "${SITE_DIR}/meta-data" \
        "${USERDATA_FILE}" \
        "${SITE_DIR}/network-config" \
        "${IMG_FILE}" \
        --qemu-commandline="-netdev vmnet-shared,id=sharednet1" \
        --qemu-commandline="-device virtio-net-pci,id=net1,netdev=sharednet1,addr=0x4,mac=de:ad:be:ef:01:00"
    fi

    # todo: create cruiser vms
    sudo virsh list --all
    ;;
  apply)
    # todo: check initialized and configured

    # create management cluster (harbor)
    export NAME="${SITE_NAME}-harbor"
    export IPADDR="$(arp -i bridge100 -a | awk \"/"${MACADDR}"/ { print $2 }\" | tr -d '()')"
    export SANS="${SITE_NAME}-harbor.kubernetes.${SITE_NAME}.labos.local"
    export CONFIG="$(yq '
      .spec.hosts[0].ssh.address = env(IPADDR) |
      .metadata.name = env(NAME) |
      .spec.k0s.config.metadata.name = env(NAME) |
      .spec.k0s.config.spec.api.sans = [env(SANS)]
    ' ${SITE_DIR}/bootstrap.yaml)"

    ssh-keygen -R "${IPADDR}"

    if [[ ${DEBUG} -eq 1 ]]; then
      set -x
      echo "${CONFIG}" | SSH_AUTH_SOCK="" k0sctl apply --debug --disable-telemetry --kubeconfig-out "${SITE_DIR}/kubeconfig-harbor.yaml" --config -
    else
      echo "${CONFIG}" | SSH_AUTH_SOCK="" k0sctl apply --disable-telemetry --kubeconfig-out "${SITE_DIR}/kubeconfig-harbor.yaml" --config -
    fi

    kustomize build "${DIR}/deployment/crd" | kubectl --kubeconfig "${SITE_DIR}/kubeconfig-harbor.yaml" apply -f -

    # todo: bgp
    # todo: edns
    # todo: create workload cluster (cruiser)
    ;;
  # fixme: cleanup
  cleanup)
    case "${ARGS}" in
      --all)
        export FULL_CLEANUP=true
        ;;
      --harbor)
        export CLEAN_HARBOR=true
        ;;
      *)
        if [[ -n "${ARGS}" ]]; then
          echo "invalid arguments"
          print_options
          exit 1
        fi
        ;;
    esac

    if [[ ${CLEAN_HARBOR} == true ]]; then
      NAME="${SITE_NAME}-harbor"
      stat "${SITE_DIR}/kubeconfig-harbor.yaml" > /dev/null 2>&1 && k0sctl reset "${SITE_DIR}/kubeconfig-harbor.yaml" --config "${SITE_DIR}/bootstrap.yaml"
      sudo virsh list --all | grep "${NAME}" | awk '{print $2}' && sudo virsh reset "${NAME}"
    fi

    if [[ ${FULL_CLEANUP} == true ]]; then
      # remove site gw
      NAME="${SITE_NAME}-gw"
      delete_vm "${NAME}"

      # remove site harbor
      NAME="${SITE_NAME}-harbor"
      delete_vm "${NAME}"

      # todo: remove site vms

      # remove site configs
      rm -rf "${SITE_DIR}"
    fi

    sudo virsh list --all
    ;;
  options)
    print_options
    exit 0
    ;;
  version)
    echo "${0} $(git describe --all)"
    exit 0
    ;;
  *)
    if [[ -n "${CMD}" ]]; then
      echo "Command not found"
      print_help
      exit 1
    fi
    exit 0
    ;;
esac

# debug: output
if [[ ${DEBUG} -eq 1 ]]; then
  echo """
site:       ${SITE_NAME}

command:    ${CMD}
arguments:  ${ARGS}

arch:       ${ARCH}
workspace:  ${DIR}
  """
fi
